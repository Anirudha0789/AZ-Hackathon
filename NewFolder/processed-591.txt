 read problem statements in hindi bengali mandarin chinese russian and vietnamese as well  chef is preparing tests for the problem move the coins he needs to create a tree gg with nn nodes numbered  through nn which is rooted at node  and a list of qq distinct reparentings  a reparenting is a pair of nodes uvuv u≠u≠ of gg and the result of applying it to gg is another graph formed as follows  take a copy of the original tree gg  in this copy remove the edge connecting the vertex uu to its parent  then add a new edge between the nodes uu and vv   as an example consider the following tree gg  we wish to apply the reparenting rr to it  the resulting graph would be  a reparenting rr is valid if the resulting graph is still a tree that is a connected graph without cycles  for the time being chef wants to generate only valid reparentings  chef has already decided on the tree gg and now he just needs to pick qq valid reparentings  he makes an initial list ll of all valid reparentings for this tree and sorts them in a special order  let ruvruv and r′u′v′r′u′v′ be valid reparentings  their order is decided as follows  if uu′uu′ then rr′rr′ if uu′uu′ then rr′rr′ if uu′uu′ find the distances of nodes vv and v′v′ from the root and denote them by hh and h′h′ respectively if uu′uu′ and hh′hh′ then rr′rr′ if uu′uu′ and hh′hh′ then rr′rr′ if uu′uu′ hh′hh′ and vv′vv′ then rr′rr′ if uu′uu′ hh′hh′ and vv′vv′ then rr′rr′  chef chooses qq integers cc…cqcc…cq removes the ccth element of ll then removes the ccth element of the resulting smaller list ll and so on until he removes the cqcqth element  the sequence cc…cqcc…cq is chosen in such a way that during this process each of them is a valid index of an element in the current list ll  this way he removes qq distinct valid reparentings and uses them in one test  because chef does not believe in making life easy for himself the sequence cc…cqcc…cq is encrypted and each of its elements cannot be decrypted until all previous reparentings are found  more formally consider a decryption key dd initially dd  you are given an encrypted sequence ee…eqee…eq  for each integer ii from  to qq chef decrypts ciei⊕dciei⊕d ⊕⊕ denotes the bitwise xor operator finds the cicith reparenting in the current list ll denoted by uiviuivi removes it from ll and updates the decryption key dd to di⋅uii⋅vidi⋅uii⋅vi  can you help chef find the qq valid reparentings corresponding to his encrypted choices calculating the final value of dd will suffice to show that you can do it input  the first line of the input contains a single integer tt denoting the number of test cases  the description of tt test cases follows  the first line of each test case contains a single integer nn  each of the next n−n− lines contains two spaceseparated integers aa and bb denoting that nodes aa and bb are connected by an edge  the next line contains a single integer qq  qq lines follow  for each valid ii the iith of these lines contains a single integer eiei   output for each test case print a single line containing one integer ― the final value of dd after processing all qq reparentings  constraints  ≤t≤≤t≤ ≤nq≤≤nq≤ ≤ab≤n≤ab≤n ≤ei≤≤ei≤ for each valid ii ≤ci≤r−i≤ci≤r−i for each valid ii where rr is the number of valid reparentings the sum of nn over all test cases does not exceed  the sum of qq over all test cases does not exceed   subtasks subtask   points  t≤t≤ nq≤nq≤  subtask   points  t≤t≤ nq≤nq≤  subtask   points original constraints                          sample input                                                                                      sample output                              explanation example case  the tree gg is  there are  reparentings uvuv  too many to draw all of them however here is a representative sampling  valid reparentings are marked with a  invalid ones with a   we can also form a table of validity of all reparentings uvuv          v                                    u                           our initial list ll then is formed by listing all pairs uvuv with a  and sorting in the order described above  we get the following list     u  v  h                                                                                                                           for ii we need to decrypt eiei to get cici then find the corresponding reparenting uiviuivi in the current list ll remove it from ll and use it to update our decryption key dd  the initial value of dd is   the first encrypted choice is ee we decrypt it to get cd⊕e⊕cd⊕e⊕ so the reparenting corresponding to the first choice is the th entry in the current list ll which is uvuv  we update dd to ⋅u⋅v⋅u⋅v and remove the th element from ll which becomes     u  v  h                                                                                                                   on to the second choice ee so c⊕c⊕ and the reparenting uvuv is   we update dd again to ⋅u⋅v⋅u⋅v and remove  from our list ll which becomes     u  v  h                                                                                                           on to the third and final choice  with ee we decrypt c⊕c⊕ so the reparenting uvuv  we use this to update dd for the final time to ⋅u⋅v⋅u⋅v  we have now processed all qq choices and the final decryption key is dd  example case  the tree gg is  there are  possible reparentings again we only show a representative sample of them and their validity  the whole table of validity of reparentings is            v                                                     u                                            by listing the valid ones and sorting them in the described order we get our initial list ll     u  v  h                                                                                                                                                                                                                                                                                           the initial value of dd is   the first encrypted value is ee and we decrypt it to get cd⊕e⊕cd⊕e⊕  the reparenting uvuv is the th element of ll i e  uvuv  we update dd to ⋅u⋅v⋅u⋅v and remove  from the list ll  to save space we do not show ll after each removal  on to the next encrypted value ee we decrypt it to get c⊕c⊕ so the reparenting uvuv is the th element of ll now the th element in the initial list i e    we update dd to ⋅u⋅v⋅u⋅v and remove  from ll  next ee so c⊕c⊕ uvuv we update dd to ⋅u⋅v⋅u⋅v and remove  from ll  next ee so c⊕c⊕ uvuv we update dd to ⋅u⋅v⋅u⋅v and remove  from ll  the last of chefs encrypted choices is ee so c⊕c⊕ uvuv  we update dd to ⋅u⋅v⋅u⋅v  we have now processed all qq of chefs choices and the final decryption key is dd   author ★ssjgz editorial  codechef comproblemsmvcntst tags                                   trees disjoint set union persistent segment trees dfs binary search prefix sum                                                              data structures graphs advanced data structures persistent structures algorithms graph algos traversals searching simple algos                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit