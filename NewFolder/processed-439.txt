 you have a grid with nn rows and mm columns in which kk cells are black and the rest are white  let ijij represent the cell in the iith row from the top and the jjth column from the left   if you are currently at cell ijij you can  move one cell down to ijij move one cell right to ijij  the cost of a path is defined as the number of times you move between two cells that have different colours  you are given qq queries  in the iith query you are initially at  and want to reach xiyixiyi with the minimum cost  for each query before you begin you can perform the following operation any number of times possibly zero  choose a column and flip the colour of all cells in this column i e  change the colour of all the black cells to white and the colour of all the white cells to black in this column  for each query what is the minimum cost of a path from  to xiyixiyi after performing this operation any number of times possibly zero note the operations applied in different queries are independent of each other  input format  the first line of the input contains a single integer tt  the number of test cases  the description of tt test cases follows  the first line of each test case contains three integers nn mm kk and qq  the number of rows the number of columns the number of black cells and the number of queries respectively  the following kk lines each contain two integers aiai and bibi  indicating that the iith black cell is at aibiaibi  the following qq lines each contain two integers xixi and yiyi  the destination cell of the iith query   output format for each test case print a single line containing qq space separated integers ― the answer for each of the qq queries  constraints  ≤t≤≤t≤ ≤nmkq≤⋅≤nmkq≤⋅ ≤aixi≤n≤aixi≤n ≤biyi≤m≤biyi≤m aibi≠ajbjaibi≠ajbj  ∀i≠j∀i≠j xiyi≠xjyjxiyi≠xjyj  ∀i≠j∀i≠j the sum of nn over all test cases does not exceed ⋅⋅ the sum of mm over all test cases does not exceed ⋅⋅ the sum of kk over all test cases does not exceed ⋅⋅ the sum of qq over all test cases does not exceed ⋅⋅                         sample input                                                                                                                              sample output                                           explanation test case   query  we are already at  so the minimum cost is    test case    initial grid  query  the only sequence of possible moves is −→−−−−−−−black to whitecost xa→black to whitecost xa  so the total cost is   query  the only sequence of possible moves is −→−−−−−−−black to whitecost xa−→−−−−−−−white to blackcost xa→black to whitecost xa→white to blackcost xa  so the cost is    it can be shown that no better answer is possible by performing any column flipping operations  test case   initial grid  query  one optimal solution is to flip columns  and  to obtain the following grid  then you can perform the following moves for a cost of    −→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa→white to whitecost xa→white to whitecost xa→white to whitecost xa  query  one optimal solution is to flip columns   then you can perform the following moves for a cost of   −→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa−→−−−−−−−white to whitecost xa→white to whitecost xa→white to whitecost xa→white to whitecost xa→white to whitecost xa→white to whitecost xa  query  one optimal solution is to flip no columns and then perform the following moves for a cost of   −→−−−−−−−white to blackcost xa→white to blackcost xa for a total cost of    test case    initial grid  query  one optimal solution is to flip no columns and then perform the following moves for a cost of    −→−−−−−−−white to blackcost xa−→−−−−−−−black to whitecost xa−→−−−−−−−white to whitecost xa→white to blackcost xa→black to whitecost xa→white to whitecost xa query  one optimal solution is to flip no columns and then perform the following moves for a cost of    −→−−−−−−−white to blackcost xa−→−−−−−−black to blackcost xa−→−−−−−−black to blackcost xa−→−−−−−−black to blackcost xa→white to blackcost xa→black to blackcost xa→black to blackcost xa→black to blackcost xa   author ★explodingfrz editorial  codechef comproblemsavoidalt tags                                   breadthfirstsearch dynamicprogramming explodingfrz greedy medium observation shortestpath slidingwindow start                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit