 read problems statements in mandarin chinese russian and bengali as well  you are given an array aa of length nn   let flrflr be the array you get from aa after removing all occurrences of alal…aralal…ar  in other words for each value in aa between the indices ll and rr you delete every occurrence of that value including occurrences outside the range lrlr  a pair lrlr is called good if ≤l≤r≤n≤l≤r≤n and flrflr is sorted in nondecreasing order  in the case that flrflr is the empty array we say it is sorted  count the number of good pairs  example suppose aa  then ff is the array we get after deleting all occurrences of the numbers   thus ff  this array is sorted in nondecreasing order so the pair  is good  input  the first line of the input contains an integer tt denoting the number of test cases  the first line of each test case contains an integer nn denoting the size of the array  the second line of each test case contains nn spaceseparated integers denoting the array aa   output for each test case output the number of good subarrays in aa in a separate line  constraints  ≤t≤≤t≤ ≤n≤×≤n≤× ≤ai≤≤ai≤ sum of nn over all test cases doesnt exceed ××                          sample input                                                                        sample output                               explanation  in the first test case  the good subarrays are     is a good subarray because the remaining array  is sorted we removed      is a good subarray because the remaining array  is sorted we removed   is a good subarray because the remaining array  is sorted  we removed   in the second test case the good subarrays are   in the third test case there are  possible good subarrays   note that  is a good subarray because the remaining array  is sorted we removed     author akashadm editorial  codechef comproblemsdelsort tags                                   sets maps hashmaps binary search two pointers                                                              data structures algorithms searching simple algos                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit