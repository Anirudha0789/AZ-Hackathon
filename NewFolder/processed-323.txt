 read problems statements in mandarin chinese russian and vietnamese as well  you are given a binary tree with nn vertices numbered  through nn  the root of the tree is vertex   there are two types of vertices  nonleaf has exactly two sons — a left son and a right son leaf doesnt have sons but it has an integer value  lets denote the number of leaves by ll  it is guaranteed that the values of all leaves are pairwise distinct numbers between  and ll inclusive  to each leaf we can assign a string in the following way  consider the simple path vv…vlvv…vl from the root to leaf vlvl the string svlsvl assigned to leaf vlvl has length l−l− for each valid ii sisi is l if vivi is the left son of vivi or r if its the right son of vivi  its clear that these strings are all pairwise distinct  lets call the tree leafsorted if the following property holds for every pair of different leaves abab sasa is lexicographically smaller than sbsb if and only if the value of aa is smaller than the value of bb  you are allowed to perform the following operation an arbitrary number of times including zero choose a nonleaf vertex and swap the edges to its left and right son  that is the original left son of this vertex becomes the right son and the original right son becomes the left son along with their whole subtrees  find the minimum number of operations needed to make the tree leafsorted or determine that its impossible  input  the first line of the input contains a single integer tt denoting the number of test cases  the description of tt test cases follows  the first line of each test case contains a single integer nn  nn lines follow  for each ii ≤i≤n≤i≤n the iith of these lines contains two spaceseparated integers ll and rr  if l−l− vertex ii is a leaf with value rr  otherwise ll and rr respectively denote the left and right son of vertex ii   output for each test case print a single line containing one integer — the minimum required number of operations or −− if its impossible to make the tree leafsorted  constraints  ≤t≤≤t≤ ≤n≤≤n≤ ≤r≤l≤r≤l for each leaf l−l− ≤lr≤n≤lr≤n for each nonleaf the values of all leaves are pairwise distinct the graph described on the input is a binary tree rooted at vertex  the sum of nn for all test cases does not exceed ⋅⋅  subtasks subtask   points  ≤t≤≤t≤ ≤n≤≤n≤  subtask   points  ≤t≤≤t≤ ≤n≤≤n≤ the sum of nn for all test cases does not exceed   subtask   points original constraints                          sample input                                                                                sample output                              explanation example case  the leaves of this tree are vertices  the strings assigned to them are ll lr r and their values are   the strings are in increasing order and the corresponding values are not so the tree isnt leafsorted  however if we swap the left and right son of the root vertex  the strings assigned to the vertices become rl rr l so the tree becomes leafsorted   author ★isaf editorial  codechef comproblemstreesort tags                                   trees binary tree bottomup dfs                                                              data structures graphs tree data structure algorithms dynamic programming dp approach graph algos traversals                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj d caml swift fort asm fs wspc lisp clisp scm guile perl erl clps prlg ick nice icon cob scm chicken pike scm qobi st nem  submit