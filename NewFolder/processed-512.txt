 stick with the strongest team thats the only way  gihun and his mates have survived the deadly night but now it’s time for the tug of war  the game proceeds as follows two teams have to face off against each other in a tug of war match  the match proceeds in a series of rounds as follows  initially one player from each team will come forward to play  the one who wins the round will stay in while the loser is eliminated  if the round is a draw both players are eliminated  when a member of a team is eliminated that team then sends another person to play in the next round  this process continues as long as both teams have at least one player left   note that if a player wins their round they must stay in for the next round — they cannot be replaced by another player  a team is said to win the match if it has at least  player remaining while all players of the opponents team are eliminated  if both teams have no players left the match is said to be a draw  gihun has to come up with a strategy for his team to win the game  he saw the opponent queue of nn players where their ithith player has strength aiai  he also knows that the opponent will send the players in the same order as they appear in aa  formally for any two players ii and jj where ijij player ii will always play before player jj  he also knows the strength of his mm players — the ithith player of his team has strength bibi   further gihun knows that when two players play against each other the player with higher strength always wins  if both players have equal strength the round is a draw  now he wants to know whether they can win a match or not and if they can what is the ordering of his team players that will let them win  in case multiple orderings are possible he would like to know the lexicographically smallest ordering  an array xx is lexicographically smaller than an array yy if there exists an index ii such that xixi  yiyi and xjyjxjyj for all ≤ji≤ji  less formally at the first index ii in which they differ xixi  yiyi  input format  the first line of input contains a single integer tt denoting the number of test cases  the description of tt test cases follows  the first line of each test case contains two spaceseparated integers nn and mm — the sizes of the opponent team and gihuns team respectively  the second line of each test case contains nn spaceseparated integers aa…anaa…an — the strengths of the opponents in order  the third line of each test case contains mm spaceseparated integers bb…bmbb…bm — the strengths of gihuns team   output format  the first line of each test case should contain a single string either “yes” or “no” denoting whether it is possible for gihuns team to win or not  if the first line contains yes print a second line containing mm spaceseparated integers — the lexicographically smallest ordering which will allow gihuns team to win   constraints  ≤t≤≤t≤ ≤nm≤≤nm≤ ≤aibj≤≤aibj≤ ≤i≤n≤i≤n ≤j≤m≤j≤m sum of nn and mm across all test cases will not exceed                          sample input                                                                                            sample output                            yes  yes    no yes     no explanation test case  there is only one possible ordering that being   the match will proceed as follows  round  bb will defeat aa aa is eliminated  round  bb will defeat aa aa is eliminated  round  bb will defeat aa aa is eliminated   bb still remains and all opponents have been defeated making this a victory for gihuns team  test case  the ordering which result in victory are  and   of these the lexicographically smallest is   let qq  the match proceeds as follows  round  qq will draw with aa eliminating both  round  qq will defeat aa eliminating aa  round  qq will draw with aa eliminating both   qq still remains so gihuns team wins  test case  it is not possible to win the match   author ★aman editorial  codechef comproblemstow tags                                   d arrays adhoc binary search two pointers                                                              data structures arrays algorithms constructive searching simple algos                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit