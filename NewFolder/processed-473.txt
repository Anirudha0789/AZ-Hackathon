 read problem statements in mandarin chinese russian and vietnamese as well  the beauty of an nonempty array of integers is defined as the difference between its largest and smallest element  for example the beauty of the array  is −−  an array aa is said to be good if it is possible to partition the elements of aa into two nonempty arrays bb and bb  such that   bb and bb have the same beauty  each element of array aa should be in exactly one array either in bb or in bb   for example the array  is good because its elements can be partitioned into two arrays bb and bb where both bb and bb have the same beauty −−−−    you are given an array aa of length nn  in one move you can  select an index ii ≤i≤n≤i≤n and either increase aiai by  or decrease aiai by    find the minimum number of moves required to make the array aa good  input format  the first line of input contains a single integer tt denoting the number of test cases  the description of tt test cases follow  each testcase contains two lines  the first line contains nn the length of the array  the second line contains nn spaceseparated integers aa   anaa   an representing the initial array   output format for each testcase output in a single line the minimum number of moves required to make the given array good  constraints  ≤t≤≤t≤ ≤n≤≤n≤ −≤ai≤−≤ai≤ sum of nn does not exceeds ⋅⋅ over all testcases                         sample input                                                               sample output                              explanation test case  we can increase the first elementaa by  in two moves  now the array aa becomes  and is good since it can be partitioned into two arrays  each with beauty    test case  the given array −−−− is good since it can be partitioned into two arrays −−−− each with beauty   alternatively it is also possible to partition it into −−−− each with beauty    author ★satyam editorial  codechef comproblemseqbeauty tags                                   implementation binary search                                                              algorithms searching                                                                                        difficulty rating                       na date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit