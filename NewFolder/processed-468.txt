  read problems statements in mandarin chinese and russian as well  as every other little boy mike has a favorite toy to play with  mikes favorite toy is a set of n disks  the boy likes to compose his disks in stacks but theres one very important rule the disks in a single stack must be ordered by their radiuses in a strictly increasing order such that the topmost disk will have the smallest radius   for example a stack of disks with radii    is valid while a stack of disks with radii    is not  little mike has recently come up with the following algorithm after the order of disks are given  first mike initiates an empty set of disk stacks  tthen mike processes the disks in the chosen order using the following pattern t if there is at least one stack such that mike can put the current disk on the top of the stack without making it invalid then he chooses the stack with the smallest top disk radius strictly greater than the radius of the current disk and puts the current disk on top of that stack  ttotherwise mike makes a new stack containing only the current disk  t  for example lets assume that the order of the disk radii is        heres how the set of the top stack disks will appear during the algorithms run  in the beginning of the algorithm the set of disk stacks is empty  after processing the first disk the set of top stack disks is   twe cannot put the second disk on the only stack that we have after processing the first disk so we make a new stack  after processing the second disk the set of top stack disks is    twe cannot put the third disk on any of the available stacks so we make a new stack  after processing the third disk the set of top stack disks is     tthe fourth disk has radius  so it can be easily put on any of the available stacks  according to the algorithm we choose the stack with the top disk radius equal to   after processing the fourth disk the set of top stack disks is     tthe fifth disk has radius  so there are two stacks we can put it on  according to the algorithm we choose the stack with the top disk radius equal to   after processing the fifth disk the set of top stack disks is     tthe sixth disk has radius  so there is only one stack we can put it on  the final set of top stack disks is      mike is really excited about his new algorithm but he has so many disks that it seems impossible to simulate the algorithm manually  you are given an array a of n integers denoting the radii of mikes disks  the disks are already ordered by mike  your task is to find the set of the stack top disk radii after the algorithm is done   input  the first line of the input contains an integer t denoting the number of test cases  the description of t test cases follows  the first line of a test description contains a single integer n  the second line of the description contains n integers denoting a      an   output  for each test case output a single line  the line should start with a positive integer s denoting the number of stacks after the algorithm is done  this should be followed by s integers on the same line denoting the stacks top disk radii in nondecreasing order  if there are multiple correct answers you are allowed to output any of them   constraints   ≤ t ≤   ≤ n ≤   ≤ ai ≤                          sample input                                                                                 sample output                                            explanation example  is already explained in the problem statement   author ★kostyaby tester ★shangjingbo editorial  codechef comproblemsstacks tags                                   multiset binary search                                                              data structures sets algorithms searching                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl perl scala lua bash js lisp sbcl pas gpc bf cloj d caml fort asm fs wspc lisp clisp scm guile perl erl clps prlg ick nice icon scm chicken pike scm qobi st nem  submit