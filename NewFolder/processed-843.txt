 read problems statements in mandarin chinese and russian as well  bob is currently at origin  bob walks on xxaxis and towards the right  in one move bob can either jump  unit to the right or  units to the right  some of these coordinates are dirty  bob wants to know the number of ways going to yy from   two ways are considered to be different if there exists an integer jj such that the location of bob after jj steps is different  sounds like a well known problem bob quickly came up with a perfect solution  a valid path should contain   which represents a clean coordinate or  which represents a dirty coordinate  if the length of the path is lenlen then bobs program calculates and prints number of ways to reach len−len− from   an integer xx is considered to be a good integer if bobs program prints xx for some valid path  you have to write a program to output yy where yy is nthnth good number in the range ll to rr  you should also print the valid path that would make bobs program output yy  if there are multiple valid paths you can output any of them  please see the output section for more details  input  the first line of the input contains an integer tt denoting the number of test cases  each test case contains  space separated integers ll rr and nn   output for each test case output the nthnth good number followed by space followed by a valid path  if no such number exists just output −−  a valid path should contain   which represent a clean coordinate or  which represents a dirty coordinate  for example      represents  coordinates   ……    out of which  and  are dirty  constraints  ≤t≤≤t≤ ≤l≤r≤≤l≤r≤ ≤n≤≤n≤  example input               example output                      explanation testcase  good numbers in range  are     stst of those is   there is one way to reach  from   testcase  good numbers in range  are     rdrd of those is   testcase  there are only  good numbers in range    author ★anudeep tester ★kostyaby editorial  codechef comproblemsanutdp tags                                   dfs bfs sorting binary search                                                              algorithms graph algos traversals searching                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages pyth   java c cpp pyth pyp cs ada text pas fpc nodejs ruby php go hask tcl perl scala lua bash js lisp sbcl pas gpc bf cloj d caml fort asm fs wspc lisp clisp scm guile perl erl clps prlg ick nice icon pike scm qobi st nem  submit