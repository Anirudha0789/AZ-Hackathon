 read problem statements in hindi bengali mandarin chinese russian and vietnamese as well  there are nn points in a plane numbered  through nn  for each valid ii the coordinates of the iith point are xiyixiyi  we want to remove all the points one by one you should choose the order in which they are removed  whenever a point is removed we compute the area of the convex hull of the remaining points  then we define a penalty pp as twice the sum of all these areas  it can be proved that pp is an integer  let mm be the penalty of an algorithm that always greedily chooses the point that minimises the area of the convex hull of the remaining points if there is more than one such point the point with the smallest xxcoordinate is chosen if there is still more than one point then the point with the smallest yycoordinate is chosen  you are given this penalty  your goal is to find a removal order that results in a smaller penalty  input  the first line of the input contains a single integer nn  nn lines follow  for each valid ii the iith of these lines contains two spaceseparated integers xixi and yiyi  the last line contains a single integer mm   output print a single line containing nn spaceseparated integers ― a permutation of the integers  through nn denoting the points in the order in which they should be removed  constraints  nn ≤xiyi≤≤xiyi≤ for each valid ii  example input                example output        explanation the points  through  are marked aa through ff in the following figure  after removing the point marked ee the convex hull of the remaining points is the quadrilateral abcdabcd  after the points bb and cc are also removed the remaining points aa ff and dd are collinear so the convex hull has zero area   the penalty pp is ⋅⋅  test generation there are four groups of test files and two test files in each group   in each file in group  the coordinates of all points are chosen uniformly randomly and independently between  and  inclusive  in each file in group  the points are chosen in the following way consider the square ss whose lower left corner is  and upper right corner is   generate a set of points by repeating the following process choose two points pp and qq with integer coordinates on the perimeter of ss uniformly randomly  consider all points with integer coordinates on the line segment pqpq  sort these points first by nondecreasing xxcoordinate and then by nondecreasing yycoordinate  add these points to the set in this order  the process stops as soon as the set contains nn pairwise distinct points  in each file in group  the points are generated similarly to group  but the points pp and qq are always chosen uniformly randomly among all points with integer coordinates inside or on the perimeter of the square ss  in each file in group  the points are generated similarly to group  but pp is always the point    scoring if pmpm you will receive the wrong answer verdict otherwise the score of a test file is m−pm−p  the score of a submission is the sum of scores of all test files  your goal is to maximise the score of your submission  there are eight test files  during the contest the displayed score will account for exactly one test file from each group i e  your score reflects your submissions performance on   of the test files  however if your program gets a nonac verdict on any test file your submissions verdict will be nonac  in other words an ac verdict denotes that your program runs successfully on all the test files  after the end of the contest your score will be changed to include the sum of your programs scores over the other  test files   author ★alei editorial  codechef comproblemsdynhul tags                                   alei alei challengeproblem dynamicprogramming greedy heuristic july randomized                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit