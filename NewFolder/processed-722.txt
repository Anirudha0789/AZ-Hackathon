 corruption is on the rise in the country of freedonia grus home   this corruption network can be represented in the form of a tree having nn nodes and n−n− edges  the nodes are numbered from  to nn and the tree is rooted at node   these nodes represent the corrupt officials and each corrupt official works under some other corrupt official except the boss who is represented by node   gru believes in divide and conquer and thinks that this network needs to be divided into as many subnetworks as possible  to achieve this the following operation can be applied by the minions any number of times even  in one operation the minions can select any one leaf node official that is an official who does not have any other official beneath him in the graph and kill him along with all his ancestors  this operation deletes those nodes along with all of their edgesconnections from the graph  hence after applying this operation on any tree it breaks into some connected components which are also trees which are the new subnetworks  now the minions are a bit lazy and will do the task someday but they need to submit a report to gru as soon as possible  help the minions by finding out the maximum number of connected components that can be achieved  input  first line will contain nn number of nodes in the tree   next n−n− lines contains  integers uu vv denoting the endpoints of the ithith edge   output  print the maximum number of connected components you can obtain after doing the operation any number of times   constraints  ≤n≤≤n≤ ≤uv≤n≤uv≤n  sample input               sample output   explanation we have  leaf nodes in this tree       suppose we delete nodes   and   after these deletions we are left with  trees   one consisting of only node  one consisting of nodes   and   this can also be achieved by deleting any of the other leaf nodes and it can be proven that we cannot obtain more than  connected components in this example   author ★panik editorial  codechef comproblemsminikill tags                                   dfs constructive                                                              algorithms graph algos traversals                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg ick nice icon cob scm chicken pike scm qobi st nem  submit