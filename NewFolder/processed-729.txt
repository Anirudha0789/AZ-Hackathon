 read problem statements in hindi bengali mandarin chinese russian and vietnamese as well  there are nn frogs numbered  through nn in a line  for each valid ii the iith frog is initially at the position ii it has weight wiwi and whenever you hit its back it jumps a distance lili to the right i e  its position increases by lili  the weights of the frogs are pairwise distinct  you can hit the back of each frog any number of times possibly zero not necessarily the same for all frogs in any order  the frogs do not intefere with each other so there can be any number of frogs at the same time at each position  your task is to sort the frogs in the increasing order of weight using the smallest possible number of hits  in other words after all the hits are performed then for each pair of frogs ijij such that wiwjwiwj the position of the iith frog should be strictly smaller than the position of the jjth frog  find the smallest number of hits needed to achieve such a state  input  the first line of the input contains a single integer tt denoting the number of test cases  the description of tt test cases follows  the first line of each test case contains a single integer nn  the second line contains nn spaceseparated integers ww…wnww…wn  the third line contains nn spaceseparated integers ll…lnll…ln   output for each test case print a single line containing one integer ― the smallest number of times you need to hit the backs of the frogs  constraints  ≤t≤⋅≤t≤⋅ ≤n≤≤n≤ ≤wi≤n≤wi≤n for each valid ii ≤li≤≤li≤ for each valid ii no two frogs have the same weight  subtasks subtask   points  tt nn  subtask   points original constraints                          sample input                                                                             sample output                               explanation example case  we can hit the back of the first frog three times  example case  we can hit the back of the first frog four times then hit the back of the second frog two times   author ★alei editorial  codechef comproblemsfrogs tags                                   adhoc sorting observation                                                              algorithms constructive                                                                                        difficulty rating                        date added  time limit  secs source limit  bytes languages cpp pyth   java c cpp pyth pyp cs ada pypy text pas fpc nodejs ruby php go hask tcl kotlin perl scala lua bash js rust lisp sbcl pas gpc bf cloj r d caml swift fort asm fs wspc lisp clisp sql scm guile perl erl clps prlg sqlq ick nice icon cob scm chicken pike scm qobi st nem  submit